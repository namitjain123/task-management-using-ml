type AnObject = Record<string, unknown>;
type SerializableValue = string | number | boolean | null | undefined | SerializableArray | SerializableObject;
type SerializableArray = SerializableValue[];
type SerializableObject = {
    [key: string]: SerializableValue;
};
type Merge<T extends object[]> = T extends [
    infer Head extends object,
    ...infer Tail extends object[]
] ? Tail extends [] ? Head : Merge<[
    MergeObjects<Head, Tail[0]>,
    ...(Tail extends [infer _First, ...infer Rest] ? Rest : [])
]> : never;
type MergeObjects<T extends object, U extends object> = {
    [K in keyof T | keyof U]: K extends keyof T & keyof U ? T[K] extends object ? U[K] extends Buffer ? T[K] : U[K] extends object ? MergeObjects<T[K], U[K]> : T[K] : U[K] : K extends keyof T ? T[K] : K extends keyof U ? U[K] : never;
};
type SnakeCase<S extends string> = S extends `${infer T}${infer U}` ? `${T extends Uppercase<T> ? "_" : ""}${Lowercase<T>}${SnakeCase<U>}` : S;
type SnakeCaseKeys<T> = T extends Array<infer U> ? Array<SnakeCaseKeys<U>> : T extends object ? {
    [K in keyof T as SnakeCase<string & K>]: SnakeCaseKeys<T[K]>;
} : T;
declare function camelize<T extends Record<string, unknown>>(source: T, depth?: boolean | number): SnakeCaseKeys<T>;
declare function camelize_str(str: string): string;
declare function compare(el1: unknown, el2: unknown): boolean;
declare function clone<T>(target: T): T;
declare function is_object(obj: unknown): obj is AnObject;
declare function is_object_literal(obj: unknown): obj is SerializableObject;
declare function merge<T extends object[]>(...args: T): Merge<T>;
declare function mutate<T extends object[]>(target: object | null | undefined, ...args: T): Merge<T>;
declare function snake_case<T extends Record<string, unknown>>(source: T, depth?: boolean | number): SnakeCaseKeys<T>;
declare function snake_case_str(str: string): string;

export { camelize, camelize_str, clone, compare, is_object, is_object_literal, merge, mutate, snake_case, snake_case_str };
